<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>Objects API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>Objects</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import pygame
import os
import sys


def load_image(name, colorkey=None):
    fullname = os.path.join(&#39;data&#39;, name)
    if not os.path.isfile(fullname):
        print(f&#34;Файл с изображением &#39;{fullname}&#39; не найден&#34;)
        sys.exit()
    image = pygame.image.load(fullname)
    return image


class Mob(pygame.sprite.Sprite):  # класс героя(далее - моба), бегающего по нижней платформе и мешающего Марио
    image_run = load_image(&#34;Mob_Cupa.png&#34;)
    image_run1 = load_image(&#34;Mob_Cupa1.png&#34;)

    def __init__(self, *group):
        super().__init__(*group)
        self.coll = 0  # счетчик для того, чтобы узнать, соприкоснулись ли Марио и моб
        self.count_mus = 0  # счетчик для музыки
        self.picture = 0  # счетчик для того, чтобы менять спрайты, т.е. создавать ощущение, что моб бежит
        self.image = Mob.image_run
        self.mob_mask = pygame.mask.from_surface(self.image)  # маска спрайта
        self.rect = self.image.get_rect()
        self.rect.x = -900  # начальная позиция
        self.rect.y = 506  # начальная позиция
        self.check = 0  # счетчик для того, чтобы узнать, соприкоснулись ли Марио и моб
        self.killed = False  # переменная для того, чтобы узнать, умер моб или нет
        self.snd = True  # дополнительная переменная для музыки

    def move(self):
        if not self.killed:
            self.rect.x += 10  # ход моба, если он жив

    def again(self):  # обновление моба. Его ход, по сути, представляет собой бег по кругу
        self.coll, self.count_mus = 0, 0
        self.image = Mob.image_run
        self.mob_mask = pygame.mask.from_surface(self.image)
        self.rect = self.image.get_rect()
        self.rect.y = 506
        self.rect.x = -100
        self.check = 0
        self.killed = False

    def fall(self, hero, shoting, pos):
        pos_m_x, pos_m_y = pos[0], pos[1]  # позиция Марио для того, чтобы узнать, соприкоснулись ли Марио и моб
        # по верху, тк в этом случае умирает моб
        if not shoting and pygame.sprite.collide_mask(self, hero) and self.rect.y in list(
                range(pos_m_y, pos_m_y + 50)) and self.rect.x in list(range(pos_m_x - 50, pos_m_x + 50)):
            if self.check == 0:
                self.coll = 1
        if self.coll == 1:
            self.killed = True
            self.check = 1
            self.rect.y += 10
            self.rect.x -= 13

    def check_fall(self):  # проверка, коснулся ли Марио моба по верху
        if self.count_mus == 0:
            if self.coll == 1:
                self.count_mus = 1
                return True
        return False

    def get_coords(self):  # координаты моба и значение переменной, обозначающее убийство моба
        return [self.rect.x, self.rect.y, self.coll]

    def sound(self):  # для правильной работы музыки
        self.snd = False

    def update(self):  # смена спрайтов
        if self.picture:
            self.image = Mob.image_run1
            self.picture = 0
            self.mob_mask = pygame.mask.from_surface(self.image)
        else:
            self.image = Mob.image_run
            self.picture = 1
            self.mob_mask = pygame.mask.from_surface(self.image)


class MobGumba(pygame.sprite.Sprite):  # класс мобов, которые катаются туда-сюда по главной и &#34;летающим&#34; платформам
    def __init__(self, x, y, *groups):
        super().__init__(*groups)
        self.image = load_image(&#34;Mob_Gumba.png&#34;)
        self.mob_mask = pygame.mask.from_surface(self.image)  # то же самое, что и в классе выше
        self.group = groups  # для появления множества мобов в игре
        self.rect = self.image.get_rect()
        self.rect.x = x
        self.rect.y = y - self.rect.h
        self.check = 0
        self.xod = 0
        self.coll = 0
        self.killed = False
        self.traectory = [3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                          3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                          -3, -3, -3, -3, -3, -3, -3, -3, -3, -3,
                          -3, -3, -3, -3, -3, -3, -3, -3, -3, -3]  # траектория &#34;езды&#34; мобов
        self.count_mus = 0  # то же самое, что и в классе выше
        self.snd = True  # то же самое, что и в классе выше

    def update(self):  # движение моба по платформе
        if not self.killed:
            self.rect.x += -self.traectory[self.xod]
            self.xod += 1
        if self.xod == 40:
            self.xod = 0

    def move(self):  # нужна для того, чтобы не было ошибки в Main.py
        pass

    def fall(self, hero, shoting, pos):  # тот же принцип и назначение, что и в классе выше
        pos_m_x, pos_m_y = pos[0], pos[1]
        if not shoting and pygame.sprite.collide_mask(self, hero) and self.rect.y in list(
                range(pos_m_y, pos_m_y + 50)) and self.rect.x in list(range(pos_m_x - 50, pos_m_x + 50)):
            if self.check == 0:
                self.coll = 1
        if self.coll == 1:
            self.killed = True
            self.check = 1
            self.rect.y += 9
            if self.rect.y &gt;= 800:  # удаление последнего спрайта на поле, тк он больше не нужен и вернуться к нему нет
                # возможности
                self.remove(self.group)

    def check_fall(self):  # то же самое, что и в классе выше
        if self.count_mus == 0:
            if self.coll == 1:
                self.count_mus = 1
                return True
        return False

    def get_coords(self):  # то же самое, что и в классе выше
        return [self.rect.x, self.rect.y, self.coll]

    def again(self):  # нужна для того, чтобы не было ошибки в Main.py
        pass

    def sound(self):  # то же самое, что и в классе выше
        self.snd = False


class MobBonus(pygame.sprite.Sprite):  # класс бонуса - сундучка, который дает 200 очков и 1 жизнь
    def __init__(self, x, y, *groups):
        super().__init__(*groups)
        self.image = load_image(&#34;bonus.png&#34;)
        self.mob_mask = pygame.mask.from_surface(self.image)
        self.group = groups
        self.rect = self.image.get_rect()
        self.rect.x = x
        self.rect.y = y - self.rect.h
        self.check = 0
        self.xod = 0
        self.coll = 0
        self.killed = False
        self.count_mus = 0
        self.snd = True
        # то же самое, что и в классе выше

    def update(self):  # то же самое, что и в классе выше
        if not self.killed:
            self.xod += 1
        if self.xod == 40:
            self.xod = 0

    def move(self):  # нужна для того, чтобы не было ошибки в Main.py
        pass

    def fall(self, hero, shoting, *args):  # то же самое, что и в классе выше
        if not shoting and pygame.sprite.collide_mask(self, hero):
            if self.check == 0:
                self.coll = 1
        if self.coll == 1:
            self.image = load_image(&#34;text_bonus.png&#34;)
            self.killed = True
            self.check = 1
            self.rect.y -= 9
            if self.rect.y &gt;= 800:
                self.remove(self.group)

    def check_fall(self):  # то же самое, что и в классе выше
        if self.count_mus == 0:
            if self.coll == 1:
                self.count_mus = 1
                return True
        return False

    def get_coords(self):  # то же самое, что и в классе выше
        return [self.rect.x, self.rect.y, self.coll]

    def again(self):  # то же самое, что и в классе выше
        pass

    def sound(self):  # то же самое, что и в классе выше
        self.snd = False


class MobMushroom(pygame.sprite.Sprite):  # класс мобов - грибочков, которые стоят на одном месте и при его убийстве
    # &#34;складываются гармошкой&#34;
    image_run = load_image(&#34;Mob_mushroom.png&#34;)
    kill = [&#34;Mob_mushroom_kill1.png&#34;, &#34;Mob_mushroom_kill2.png&#34;, &#34;Mob_mushroom_kill3.png&#34;, &#34;Mob_mushroom_kill4.png&#34;,
            &#34;Mob_mushroom_kill5.png&#34;, &#34;Mob_mushroom_kill6.png&#34;, &#34;Mob_mushroom_kill7.png&#34;, &#34;Mob_mushroom_kill8.png&#34;,
            &#34;Mob_mushroom_kill9.png&#34;, &#34;Mob_mushroom_kill10.png&#34;, &#34;Mob_mushroom_kill11.png&#34;,
            &#34;Mob_mushroom_kill12.png&#34;, &#34;Mob_mushroom_kill13.png&#34;, &#34;Mob_mushroom_kill14.png&#34;,
            &#34;Mob_mushroom_kill15.png&#34;, &#34;Mob_mushroom_kill16.png&#34;, &#34;Mob_mushroom_kill17.png&#34;, ]

    def __init__(self, x, y, *groups):
        super().__init__(*groups)
        self.image = load_image(&#34;Mob_mushroom.png&#34;)
        self.mob_mask = pygame.mask.from_surface(self.image)
        self.group = groups
        self.rect = self.image.get_rect()
        self.rect.x = x
        self.rect.y = y - self.rect.h
        self.check = 0
        self.xod = 0
        self.coll = 0
        self.killed = False
        self.count_mus = 0
        self.snd = True
        self.picture = 0
        # то же самое, что и в классе выше

    def update(self):  # то же самое, что и в классе выше
        if not self.killed:
            self.xod += 1
        if self.xod == 40:
            self.xod = 0

    def move(self):  # нужна для того, чтобы не было ошибки в Main.py
        pass

    def fall(self, hero, shoting, pos):  # то же самое, что и в классе выше
        pos_m_x, pos_m_y = pos[0], pos[1]
        if not shoting and pygame.sprite.collide_mask(self, hero) and self.rect.y in list(
                range(pos_m_y, pos_m_y + 50)) and self.rect.x in list(range(pos_m_x - 50, pos_m_x + 50)):
            if self.check == 0:
                self.coll = 1
        if self.coll == 1:
            if self.picture == -1:
                self.image = MobMushroom.image_run
            self.image = load_image(MobMushroom.kill[self.picture])
            self.mob_mask = pygame.mask.from_surface(self.image)
            if self.picture != 17 and self.picture != -1:
                if self.picture == 16:
                    self.rect.y += 3
                else:
                    self.rect.y += 3
            self.picture += 1
            if self.picture == 17:
                self.picture = -1
                self.coll = 0
                self.check = 0
            self.killed = True
            self.check = 1
            if self.rect.y &gt;= 400:
                self.remove(self.group)

    def check_fall(self):  # то же самое, что и в классе выше
        if self.count_mus == 0:
            if self.coll == 1:
                self.count_mus = 1
                return True
        return False

    def get_coords(self):  # то же самое, что и в классе выше
        return [self.rect.x, self.rect.y, self.coll]

    def again(self):  # нужна для того, чтобы не было ошибки в Main.py
        pass

    def sound(self):  # то же самое, что и в классе выше
        self.snd = False


&#34;&#34;&#34;
КЛАССЫ ОБЪЕКТОВ
&#34;&#34;&#34;</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="Objects.load_image"><code class="name flex">
<span>def <span class="ident">load_image</span></span>(<span>name, colorkey=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_image(name, colorkey=None):
    fullname = os.path.join(&#39;data&#39;, name)
    if not os.path.isfile(fullname):
        print(f&#34;Файл с изображением &#39;{fullname}&#39; не найден&#34;)
        sys.exit()
    image = pygame.image.load(fullname)
    return image</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="Objects.Mob"><code class="flex name class">
<span>class <span class="ident">Mob</span></span>
<span>(</span><span>*group)</span>
</code></dt>
<dd>
<div class="desc"><p>simple base class for visible game objects</p>
<p>pygame.sprite.Sprite(*groups): return Sprite</p>
<p>The base class for visible game objects. Derived classes will want to
override the Sprite.update() method and assign Sprite.image and Sprite.rect
attributes.
The initializer can accept any number of Group instances that
the Sprite will become a member of.</p>
<p>When subclassing the Sprite class, be sure to call the base initializer
before adding the Sprite to Groups.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Mob(pygame.sprite.Sprite):  # класс героя(далее - моба), бегающего по нижней платформе и мешающего Марио
    image_run = load_image(&#34;Mob_Cupa.png&#34;)
    image_run1 = load_image(&#34;Mob_Cupa1.png&#34;)

    def __init__(self, *group):
        super().__init__(*group)
        self.coll = 0  # счетчик для того, чтобы узнать, соприкоснулись ли Марио и моб
        self.count_mus = 0  # счетчик для музыки
        self.picture = 0  # счетчик для того, чтобы менять спрайты, т.е. создавать ощущение, что моб бежит
        self.image = Mob.image_run
        self.mob_mask = pygame.mask.from_surface(self.image)  # маска спрайта
        self.rect = self.image.get_rect()
        self.rect.x = -900  # начальная позиция
        self.rect.y = 506  # начальная позиция
        self.check = 0  # счетчик для того, чтобы узнать, соприкоснулись ли Марио и моб
        self.killed = False  # переменная для того, чтобы узнать, умер моб или нет
        self.snd = True  # дополнительная переменная для музыки

    def move(self):
        if not self.killed:
            self.rect.x += 10  # ход моба, если он жив

    def again(self):  # обновление моба. Его ход, по сути, представляет собой бег по кругу
        self.coll, self.count_mus = 0, 0
        self.image = Mob.image_run
        self.mob_mask = pygame.mask.from_surface(self.image)
        self.rect = self.image.get_rect()
        self.rect.y = 506
        self.rect.x = -100
        self.check = 0
        self.killed = False

    def fall(self, hero, shoting, pos):
        pos_m_x, pos_m_y = pos[0], pos[1]  # позиция Марио для того, чтобы узнать, соприкоснулись ли Марио и моб
        # по верху, тк в этом случае умирает моб
        if not shoting and pygame.sprite.collide_mask(self, hero) and self.rect.y in list(
                range(pos_m_y, pos_m_y + 50)) and self.rect.x in list(range(pos_m_x - 50, pos_m_x + 50)):
            if self.check == 0:
                self.coll = 1
        if self.coll == 1:
            self.killed = True
            self.check = 1
            self.rect.y += 10
            self.rect.x -= 13

    def check_fall(self):  # проверка, коснулся ли Марио моба по верху
        if self.count_mus == 0:
            if self.coll == 1:
                self.count_mus = 1
                return True
        return False

    def get_coords(self):  # координаты моба и значение переменной, обозначающее убийство моба
        return [self.rect.x, self.rect.y, self.coll]

    def sound(self):  # для правильной работы музыки
        self.snd = False

    def update(self):  # смена спрайтов
        if self.picture:
            self.image = Mob.image_run1
            self.picture = 0
            self.mob_mask = pygame.mask.from_surface(self.image)
        else:
            self.image = Mob.image_run
            self.picture = 1
            self.mob_mask = pygame.mask.from_surface(self.image)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>pygame.sprite.Sprite</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="Objects.Mob.image_run"><code class="name">var <span class="ident">image_run</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="Objects.Mob.image_run1"><code class="name">var <span class="ident">image_run1</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="Objects.Mob.again"><code class="name flex">
<span>def <span class="ident">again</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def again(self):  # обновление моба. Его ход, по сути, представляет собой бег по кругу
    self.coll, self.count_mus = 0, 0
    self.image = Mob.image_run
    self.mob_mask = pygame.mask.from_surface(self.image)
    self.rect = self.image.get_rect()
    self.rect.y = 506
    self.rect.x = -100
    self.check = 0
    self.killed = False</code></pre>
</details>
</dd>
<dt id="Objects.Mob.check_fall"><code class="name flex">
<span>def <span class="ident">check_fall</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_fall(self):  # проверка, коснулся ли Марио моба по верху
    if self.count_mus == 0:
        if self.coll == 1:
            self.count_mus = 1
            return True
    return False</code></pre>
</details>
</dd>
<dt id="Objects.Mob.fall"><code class="name flex">
<span>def <span class="ident">fall</span></span>(<span>self, hero, shoting, pos)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fall(self, hero, shoting, pos):
    pos_m_x, pos_m_y = pos[0], pos[1]  # позиция Марио для того, чтобы узнать, соприкоснулись ли Марио и моб
    # по верху, тк в этом случае умирает моб
    if not shoting and pygame.sprite.collide_mask(self, hero) and self.rect.y in list(
            range(pos_m_y, pos_m_y + 50)) and self.rect.x in list(range(pos_m_x - 50, pos_m_x + 50)):
        if self.check == 0:
            self.coll = 1
    if self.coll == 1:
        self.killed = True
        self.check = 1
        self.rect.y += 10
        self.rect.x -= 13</code></pre>
</details>
</dd>
<dt id="Objects.Mob.get_coords"><code class="name flex">
<span>def <span class="ident">get_coords</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_coords(self):  # координаты моба и значение переменной, обозначающее убийство моба
    return [self.rect.x, self.rect.y, self.coll]</code></pre>
</details>
</dd>
<dt id="Objects.Mob.move"><code class="name flex">
<span>def <span class="ident">move</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def move(self):
    if not self.killed:
        self.rect.x += 10  # ход моба, если он жив</code></pre>
</details>
</dd>
<dt id="Objects.Mob.sound"><code class="name flex">
<span>def <span class="ident">sound</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sound(self):  # для правильной работы музыки
    self.snd = False</code></pre>
</details>
</dd>
<dt id="Objects.Mob.update"><code class="name flex">
<span>def <span class="ident">update</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>method to control sprite behavior</p>
<p>Sprite.update(<em>args, </em>*kwargs):</p>
<p>The default implementation of this method does nothing; it's just a
convenient "hook" that you can override. This method is called by
Group.update() with whatever arguments you give it.</p>
<p>There is no need to use this method if not using the convenience
method by the same name in the Group class.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update(self):  # смена спрайтов
    if self.picture:
        self.image = Mob.image_run1
        self.picture = 0
        self.mob_mask = pygame.mask.from_surface(self.image)
    else:
        self.image = Mob.image_run
        self.picture = 1
        self.mob_mask = pygame.mask.from_surface(self.image)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="Objects.MobBonus"><code class="flex name class">
<span>class <span class="ident">MobBonus</span></span>
<span>(</span><span>x, y, *groups)</span>
</code></dt>
<dd>
<div class="desc"><p>simple base class for visible game objects</p>
<p>pygame.sprite.Sprite(*groups): return Sprite</p>
<p>The base class for visible game objects. Derived classes will want to
override the Sprite.update() method and assign Sprite.image and Sprite.rect
attributes.
The initializer can accept any number of Group instances that
the Sprite will become a member of.</p>
<p>When subclassing the Sprite class, be sure to call the base initializer
before adding the Sprite to Groups.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MobBonus(pygame.sprite.Sprite):  # класс бонуса - сундучка, который дает 200 очков и 1 жизнь
    def __init__(self, x, y, *groups):
        super().__init__(*groups)
        self.image = load_image(&#34;bonus.png&#34;)
        self.mob_mask = pygame.mask.from_surface(self.image)
        self.group = groups
        self.rect = self.image.get_rect()
        self.rect.x = x
        self.rect.y = y - self.rect.h
        self.check = 0
        self.xod = 0
        self.coll = 0
        self.killed = False
        self.count_mus = 0
        self.snd = True
        # то же самое, что и в классе выше

    def update(self):  # то же самое, что и в классе выше
        if not self.killed:
            self.xod += 1
        if self.xod == 40:
            self.xod = 0

    def move(self):  # нужна для того, чтобы не было ошибки в Main.py
        pass

    def fall(self, hero, shoting, *args):  # то же самое, что и в классе выше
        if not shoting and pygame.sprite.collide_mask(self, hero):
            if self.check == 0:
                self.coll = 1
        if self.coll == 1:
            self.image = load_image(&#34;text_bonus.png&#34;)
            self.killed = True
            self.check = 1
            self.rect.y -= 9
            if self.rect.y &gt;= 800:
                self.remove(self.group)

    def check_fall(self):  # то же самое, что и в классе выше
        if self.count_mus == 0:
            if self.coll == 1:
                self.count_mus = 1
                return True
        return False

    def get_coords(self):  # то же самое, что и в классе выше
        return [self.rect.x, self.rect.y, self.coll]

    def again(self):  # то же самое, что и в классе выше
        pass

    def sound(self):  # то же самое, что и в классе выше
        self.snd = False</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>pygame.sprite.Sprite</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="Objects.MobBonus.again"><code class="name flex">
<span>def <span class="ident">again</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def again(self):  # то же самое, что и в классе выше
    pass</code></pre>
</details>
</dd>
<dt id="Objects.MobBonus.check_fall"><code class="name flex">
<span>def <span class="ident">check_fall</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_fall(self):  # то же самое, что и в классе выше
    if self.count_mus == 0:
        if self.coll == 1:
            self.count_mus = 1
            return True
    return False</code></pre>
</details>
</dd>
<dt id="Objects.MobBonus.fall"><code class="name flex">
<span>def <span class="ident">fall</span></span>(<span>self, hero, shoting, *args)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fall(self, hero, shoting, *args):  # то же самое, что и в классе выше
    if not shoting and pygame.sprite.collide_mask(self, hero):
        if self.check == 0:
            self.coll = 1
    if self.coll == 1:
        self.image = load_image(&#34;text_bonus.png&#34;)
        self.killed = True
        self.check = 1
        self.rect.y -= 9
        if self.rect.y &gt;= 800:
            self.remove(self.group)</code></pre>
</details>
</dd>
<dt id="Objects.MobBonus.get_coords"><code class="name flex">
<span>def <span class="ident">get_coords</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_coords(self):  # то же самое, что и в классе выше
    return [self.rect.x, self.rect.y, self.coll]</code></pre>
</details>
</dd>
<dt id="Objects.MobBonus.move"><code class="name flex">
<span>def <span class="ident">move</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def move(self):  # нужна для того, чтобы не было ошибки в Main.py
    pass</code></pre>
</details>
</dd>
<dt id="Objects.MobBonus.sound"><code class="name flex">
<span>def <span class="ident">sound</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sound(self):  # то же самое, что и в классе выше
    self.snd = False</code></pre>
</details>
</dd>
<dt id="Objects.MobBonus.update"><code class="name flex">
<span>def <span class="ident">update</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>method to control sprite behavior</p>
<p>Sprite.update(<em>args, </em>*kwargs):</p>
<p>The default implementation of this method does nothing; it's just a
convenient "hook" that you can override. This method is called by
Group.update() with whatever arguments you give it.</p>
<p>There is no need to use this method if not using the convenience
method by the same name in the Group class.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update(self):  # то же самое, что и в классе выше
    if not self.killed:
        self.xod += 1
    if self.xod == 40:
        self.xod = 0</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="Objects.MobGumba"><code class="flex name class">
<span>class <span class="ident">MobGumba</span></span>
<span>(</span><span>x, y, *groups)</span>
</code></dt>
<dd>
<div class="desc"><p>simple base class for visible game objects</p>
<p>pygame.sprite.Sprite(*groups): return Sprite</p>
<p>The base class for visible game objects. Derived classes will want to
override the Sprite.update() method and assign Sprite.image and Sprite.rect
attributes.
The initializer can accept any number of Group instances that
the Sprite will become a member of.</p>
<p>When subclassing the Sprite class, be sure to call the base initializer
before adding the Sprite to Groups.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MobGumba(pygame.sprite.Sprite):  # класс мобов, которые катаются туда-сюда по главной и &#34;летающим&#34; платформам
    def __init__(self, x, y, *groups):
        super().__init__(*groups)
        self.image = load_image(&#34;Mob_Gumba.png&#34;)
        self.mob_mask = pygame.mask.from_surface(self.image)  # то же самое, что и в классе выше
        self.group = groups  # для появления множества мобов в игре
        self.rect = self.image.get_rect()
        self.rect.x = x
        self.rect.y = y - self.rect.h
        self.check = 0
        self.xod = 0
        self.coll = 0
        self.killed = False
        self.traectory = [3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                          3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                          -3, -3, -3, -3, -3, -3, -3, -3, -3, -3,
                          -3, -3, -3, -3, -3, -3, -3, -3, -3, -3]  # траектория &#34;езды&#34; мобов
        self.count_mus = 0  # то же самое, что и в классе выше
        self.snd = True  # то же самое, что и в классе выше

    def update(self):  # движение моба по платформе
        if not self.killed:
            self.rect.x += -self.traectory[self.xod]
            self.xod += 1
        if self.xod == 40:
            self.xod = 0

    def move(self):  # нужна для того, чтобы не было ошибки в Main.py
        pass

    def fall(self, hero, shoting, pos):  # тот же принцип и назначение, что и в классе выше
        pos_m_x, pos_m_y = pos[0], pos[1]
        if not shoting and pygame.sprite.collide_mask(self, hero) and self.rect.y in list(
                range(pos_m_y, pos_m_y + 50)) and self.rect.x in list(range(pos_m_x - 50, pos_m_x + 50)):
            if self.check == 0:
                self.coll = 1
        if self.coll == 1:
            self.killed = True
            self.check = 1
            self.rect.y += 9
            if self.rect.y &gt;= 800:  # удаление последнего спрайта на поле, тк он больше не нужен и вернуться к нему нет
                # возможности
                self.remove(self.group)

    def check_fall(self):  # то же самое, что и в классе выше
        if self.count_mus == 0:
            if self.coll == 1:
                self.count_mus = 1
                return True
        return False

    def get_coords(self):  # то же самое, что и в классе выше
        return [self.rect.x, self.rect.y, self.coll]

    def again(self):  # нужна для того, чтобы не было ошибки в Main.py
        pass

    def sound(self):  # то же самое, что и в классе выше
        self.snd = False</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>pygame.sprite.Sprite</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="Objects.MobGumba.again"><code class="name flex">
<span>def <span class="ident">again</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def again(self):  # нужна для того, чтобы не было ошибки в Main.py
    pass</code></pre>
</details>
</dd>
<dt id="Objects.MobGumba.check_fall"><code class="name flex">
<span>def <span class="ident">check_fall</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_fall(self):  # то же самое, что и в классе выше
    if self.count_mus == 0:
        if self.coll == 1:
            self.count_mus = 1
            return True
    return False</code></pre>
</details>
</dd>
<dt id="Objects.MobGumba.fall"><code class="name flex">
<span>def <span class="ident">fall</span></span>(<span>self, hero, shoting, pos)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fall(self, hero, shoting, pos):  # тот же принцип и назначение, что и в классе выше
    pos_m_x, pos_m_y = pos[0], pos[1]
    if not shoting and pygame.sprite.collide_mask(self, hero) and self.rect.y in list(
            range(pos_m_y, pos_m_y + 50)) and self.rect.x in list(range(pos_m_x - 50, pos_m_x + 50)):
        if self.check == 0:
            self.coll = 1
    if self.coll == 1:
        self.killed = True
        self.check = 1
        self.rect.y += 9
        if self.rect.y &gt;= 800:  # удаление последнего спрайта на поле, тк он больше не нужен и вернуться к нему нет
            # возможности
            self.remove(self.group)</code></pre>
</details>
</dd>
<dt id="Objects.MobGumba.get_coords"><code class="name flex">
<span>def <span class="ident">get_coords</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_coords(self):  # то же самое, что и в классе выше
    return [self.rect.x, self.rect.y, self.coll]</code></pre>
</details>
</dd>
<dt id="Objects.MobGumba.move"><code class="name flex">
<span>def <span class="ident">move</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def move(self):  # нужна для того, чтобы не было ошибки в Main.py
    pass</code></pre>
</details>
</dd>
<dt id="Objects.MobGumba.sound"><code class="name flex">
<span>def <span class="ident">sound</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sound(self):  # то же самое, что и в классе выше
    self.snd = False</code></pre>
</details>
</dd>
<dt id="Objects.MobGumba.update"><code class="name flex">
<span>def <span class="ident">update</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>method to control sprite behavior</p>
<p>Sprite.update(<em>args, </em>*kwargs):</p>
<p>The default implementation of this method does nothing; it's just a
convenient "hook" that you can override. This method is called by
Group.update() with whatever arguments you give it.</p>
<p>There is no need to use this method if not using the convenience
method by the same name in the Group class.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update(self):  # движение моба по платформе
    if not self.killed:
        self.rect.x += -self.traectory[self.xod]
        self.xod += 1
    if self.xod == 40:
        self.xod = 0</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="Objects.MobMushroom"><code class="flex name class">
<span>class <span class="ident">MobMushroom</span></span>
<span>(</span><span>x, y, *groups)</span>
</code></dt>
<dd>
<div class="desc"><p>simple base class for visible game objects</p>
<p>pygame.sprite.Sprite(*groups): return Sprite</p>
<p>The base class for visible game objects. Derived classes will want to
override the Sprite.update() method and assign Sprite.image and Sprite.rect
attributes.
The initializer can accept any number of Group instances that
the Sprite will become a member of.</p>
<p>When subclassing the Sprite class, be sure to call the base initializer
before adding the Sprite to Groups.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MobMushroom(pygame.sprite.Sprite):  # класс мобов - грибочков, которые стоят на одном месте и при его убийстве
    # &#34;складываются гармошкой&#34;
    image_run = load_image(&#34;Mob_mushroom.png&#34;)
    kill = [&#34;Mob_mushroom_kill1.png&#34;, &#34;Mob_mushroom_kill2.png&#34;, &#34;Mob_mushroom_kill3.png&#34;, &#34;Mob_mushroom_kill4.png&#34;,
            &#34;Mob_mushroom_kill5.png&#34;, &#34;Mob_mushroom_kill6.png&#34;, &#34;Mob_mushroom_kill7.png&#34;, &#34;Mob_mushroom_kill8.png&#34;,
            &#34;Mob_mushroom_kill9.png&#34;, &#34;Mob_mushroom_kill10.png&#34;, &#34;Mob_mushroom_kill11.png&#34;,
            &#34;Mob_mushroom_kill12.png&#34;, &#34;Mob_mushroom_kill13.png&#34;, &#34;Mob_mushroom_kill14.png&#34;,
            &#34;Mob_mushroom_kill15.png&#34;, &#34;Mob_mushroom_kill16.png&#34;, &#34;Mob_mushroom_kill17.png&#34;, ]

    def __init__(self, x, y, *groups):
        super().__init__(*groups)
        self.image = load_image(&#34;Mob_mushroom.png&#34;)
        self.mob_mask = pygame.mask.from_surface(self.image)
        self.group = groups
        self.rect = self.image.get_rect()
        self.rect.x = x
        self.rect.y = y - self.rect.h
        self.check = 0
        self.xod = 0
        self.coll = 0
        self.killed = False
        self.count_mus = 0
        self.snd = True
        self.picture = 0
        # то же самое, что и в классе выше

    def update(self):  # то же самое, что и в классе выше
        if not self.killed:
            self.xod += 1
        if self.xod == 40:
            self.xod = 0

    def move(self):  # нужна для того, чтобы не было ошибки в Main.py
        pass

    def fall(self, hero, shoting, pos):  # то же самое, что и в классе выше
        pos_m_x, pos_m_y = pos[0], pos[1]
        if not shoting and pygame.sprite.collide_mask(self, hero) and self.rect.y in list(
                range(pos_m_y, pos_m_y + 50)) and self.rect.x in list(range(pos_m_x - 50, pos_m_x + 50)):
            if self.check == 0:
                self.coll = 1
        if self.coll == 1:
            if self.picture == -1:
                self.image = MobMushroom.image_run
            self.image = load_image(MobMushroom.kill[self.picture])
            self.mob_mask = pygame.mask.from_surface(self.image)
            if self.picture != 17 and self.picture != -1:
                if self.picture == 16:
                    self.rect.y += 3
                else:
                    self.rect.y += 3
            self.picture += 1
            if self.picture == 17:
                self.picture = -1
                self.coll = 0
                self.check = 0
            self.killed = True
            self.check = 1
            if self.rect.y &gt;= 400:
                self.remove(self.group)

    def check_fall(self):  # то же самое, что и в классе выше
        if self.count_mus == 0:
            if self.coll == 1:
                self.count_mus = 1
                return True
        return False

    def get_coords(self):  # то же самое, что и в классе выше
        return [self.rect.x, self.rect.y, self.coll]

    def again(self):  # нужна для того, чтобы не было ошибки в Main.py
        pass

    def sound(self):  # то же самое, что и в классе выше
        self.snd = False</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>pygame.sprite.Sprite</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="Objects.MobMushroom.image_run"><code class="name">var <span class="ident">image_run</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="Objects.MobMushroom.kill"><code class="name">var <span class="ident">kill</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="Objects.MobMushroom.again"><code class="name flex">
<span>def <span class="ident">again</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def again(self):  # нужна для того, чтобы не было ошибки в Main.py
    pass</code></pre>
</details>
</dd>
<dt id="Objects.MobMushroom.check_fall"><code class="name flex">
<span>def <span class="ident">check_fall</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_fall(self):  # то же самое, что и в классе выше
    if self.count_mus == 0:
        if self.coll == 1:
            self.count_mus = 1
            return True
    return False</code></pre>
</details>
</dd>
<dt id="Objects.MobMushroom.fall"><code class="name flex">
<span>def <span class="ident">fall</span></span>(<span>self, hero, shoting, pos)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fall(self, hero, shoting, pos):  # то же самое, что и в классе выше
    pos_m_x, pos_m_y = pos[0], pos[1]
    if not shoting and pygame.sprite.collide_mask(self, hero) and self.rect.y in list(
            range(pos_m_y, pos_m_y + 50)) and self.rect.x in list(range(pos_m_x - 50, pos_m_x + 50)):
        if self.check == 0:
            self.coll = 1
    if self.coll == 1:
        if self.picture == -1:
            self.image = MobMushroom.image_run
        self.image = load_image(MobMushroom.kill[self.picture])
        self.mob_mask = pygame.mask.from_surface(self.image)
        if self.picture != 17 and self.picture != -1:
            if self.picture == 16:
                self.rect.y += 3
            else:
                self.rect.y += 3
        self.picture += 1
        if self.picture == 17:
            self.picture = -1
            self.coll = 0
            self.check = 0
        self.killed = True
        self.check = 1
        if self.rect.y &gt;= 400:
            self.remove(self.group)</code></pre>
</details>
</dd>
<dt id="Objects.MobMushroom.get_coords"><code class="name flex">
<span>def <span class="ident">get_coords</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_coords(self):  # то же самое, что и в классе выше
    return [self.rect.x, self.rect.y, self.coll]</code></pre>
</details>
</dd>
<dt id="Objects.MobMushroom.move"><code class="name flex">
<span>def <span class="ident">move</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def move(self):  # нужна для того, чтобы не было ошибки в Main.py
    pass</code></pre>
</details>
</dd>
<dt id="Objects.MobMushroom.sound"><code class="name flex">
<span>def <span class="ident">sound</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sound(self):  # то же самое, что и в классе выше
    self.snd = False</code></pre>
</details>
</dd>
<dt id="Objects.MobMushroom.update"><code class="name flex">
<span>def <span class="ident">update</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>method to control sprite behavior</p>
<p>Sprite.update(<em>args, </em>*kwargs):</p>
<p>The default implementation of this method does nothing; it's just a
convenient "hook" that you can override. This method is called by
Group.update() with whatever arguments you give it.</p>
<p>There is no need to use this method if not using the convenience
method by the same name in the Group class.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update(self):  # то же самое, что и в классе выше
    if not self.killed:
        self.xod += 1
    if self.xod == 40:
        self.xod = 0</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="Objects.load_image" href="#Objects.load_image">load_image</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="Objects.Mob" href="#Objects.Mob">Mob</a></code></h4>
<ul class="two-column">
<li><code><a title="Objects.Mob.again" href="#Objects.Mob.again">again</a></code></li>
<li><code><a title="Objects.Mob.check_fall" href="#Objects.Mob.check_fall">check_fall</a></code></li>
<li><code><a title="Objects.Mob.fall" href="#Objects.Mob.fall">fall</a></code></li>
<li><code><a title="Objects.Mob.get_coords" href="#Objects.Mob.get_coords">get_coords</a></code></li>
<li><code><a title="Objects.Mob.image_run" href="#Objects.Mob.image_run">image_run</a></code></li>
<li><code><a title="Objects.Mob.image_run1" href="#Objects.Mob.image_run1">image_run1</a></code></li>
<li><code><a title="Objects.Mob.move" href="#Objects.Mob.move">move</a></code></li>
<li><code><a title="Objects.Mob.sound" href="#Objects.Mob.sound">sound</a></code></li>
<li><code><a title="Objects.Mob.update" href="#Objects.Mob.update">update</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="Objects.MobBonus" href="#Objects.MobBonus">MobBonus</a></code></h4>
<ul class="two-column">
<li><code><a title="Objects.MobBonus.again" href="#Objects.MobBonus.again">again</a></code></li>
<li><code><a title="Objects.MobBonus.check_fall" href="#Objects.MobBonus.check_fall">check_fall</a></code></li>
<li><code><a title="Objects.MobBonus.fall" href="#Objects.MobBonus.fall">fall</a></code></li>
<li><code><a title="Objects.MobBonus.get_coords" href="#Objects.MobBonus.get_coords">get_coords</a></code></li>
<li><code><a title="Objects.MobBonus.move" href="#Objects.MobBonus.move">move</a></code></li>
<li><code><a title="Objects.MobBonus.sound" href="#Objects.MobBonus.sound">sound</a></code></li>
<li><code><a title="Objects.MobBonus.update" href="#Objects.MobBonus.update">update</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="Objects.MobGumba" href="#Objects.MobGumba">MobGumba</a></code></h4>
<ul class="two-column">
<li><code><a title="Objects.MobGumba.again" href="#Objects.MobGumba.again">again</a></code></li>
<li><code><a title="Objects.MobGumba.check_fall" href="#Objects.MobGumba.check_fall">check_fall</a></code></li>
<li><code><a title="Objects.MobGumba.fall" href="#Objects.MobGumba.fall">fall</a></code></li>
<li><code><a title="Objects.MobGumba.get_coords" href="#Objects.MobGumba.get_coords">get_coords</a></code></li>
<li><code><a title="Objects.MobGumba.move" href="#Objects.MobGumba.move">move</a></code></li>
<li><code><a title="Objects.MobGumba.sound" href="#Objects.MobGumba.sound">sound</a></code></li>
<li><code><a title="Objects.MobGumba.update" href="#Objects.MobGumba.update">update</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="Objects.MobMushroom" href="#Objects.MobMushroom">MobMushroom</a></code></h4>
<ul class="two-column">
<li><code><a title="Objects.MobMushroom.again" href="#Objects.MobMushroom.again">again</a></code></li>
<li><code><a title="Objects.MobMushroom.check_fall" href="#Objects.MobMushroom.check_fall">check_fall</a></code></li>
<li><code><a title="Objects.MobMushroom.fall" href="#Objects.MobMushroom.fall">fall</a></code></li>
<li><code><a title="Objects.MobMushroom.get_coords" href="#Objects.MobMushroom.get_coords">get_coords</a></code></li>
<li><code><a title="Objects.MobMushroom.image_run" href="#Objects.MobMushroom.image_run">image_run</a></code></li>
<li><code><a title="Objects.MobMushroom.kill" href="#Objects.MobMushroom.kill">kill</a></code></li>
<li><code><a title="Objects.MobMushroom.move" href="#Objects.MobMushroom.move">move</a></code></li>
<li><code><a title="Objects.MobMushroom.sound" href="#Objects.MobMushroom.sound">sound</a></code></li>
<li><code><a title="Objects.MobMushroom.update" href="#Objects.MobMushroom.update">update</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>